// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'part.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Part {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() point,
    required TResult Function() newPoint,
    required TResult Function() noPart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? point,
    TResult? Function()? newPoint,
    TResult? Function()? noPart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? point,
    TResult Function()? newPoint,
    TResult Function()? noPart,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Point value) point,
    required TResult Function(_NewPoint value) newPoint,
    required TResult Function(_NoPart value) noPart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Point value)? point,
    TResult? Function(_NewPoint value)? newPoint,
    TResult? Function(_NoPart value)? noPart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Point value)? point,
    TResult Function(_NewPoint value)? newPoint,
    TResult Function(_NoPart value)? noPart,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PartCopyWith<$Res> {
  factory $PartCopyWith(Part value, $Res Function(Part) then) =
      _$PartCopyWithImpl<$Res, Part>;
}

/// @nodoc
class _$PartCopyWithImpl<$Res, $Val extends Part>
    implements $PartCopyWith<$Res> {
  _$PartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PointImplCopyWith<$Res> {
  factory _$$PointImplCopyWith(
          _$PointImpl value, $Res Function(_$PointImpl) then) =
      __$$PointImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PointImplCopyWithImpl<$Res>
    extends _$PartCopyWithImpl<$Res, _$PointImpl>
    implements _$$PointImplCopyWith<$Res> {
  __$$PointImplCopyWithImpl(
      _$PointImpl _value, $Res Function(_$PointImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PointImpl implements _Point {
  const _$PointImpl();

  @override
  String toString() {
    return 'Part.point()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PointImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() point,
    required TResult Function() newPoint,
    required TResult Function() noPart,
  }) {
    return point();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? point,
    TResult? Function()? newPoint,
    TResult? Function()? noPart,
  }) {
    return point?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? point,
    TResult Function()? newPoint,
    TResult Function()? noPart,
    required TResult orElse(),
  }) {
    if (point != null) {
      return point();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Point value) point,
    required TResult Function(_NewPoint value) newPoint,
    required TResult Function(_NoPart value) noPart,
  }) {
    return point(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Point value)? point,
    TResult? Function(_NewPoint value)? newPoint,
    TResult? Function(_NoPart value)? noPart,
  }) {
    return point?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Point value)? point,
    TResult Function(_NewPoint value)? newPoint,
    TResult Function(_NoPart value)? noPart,
    required TResult orElse(),
  }) {
    if (point != null) {
      return point(this);
    }
    return orElse();
  }
}

abstract class _Point implements Part {
  const factory _Point() = _$PointImpl;
}

/// @nodoc
abstract class _$$NewPointImplCopyWith<$Res> {
  factory _$$NewPointImplCopyWith(
          _$NewPointImpl value, $Res Function(_$NewPointImpl) then) =
      __$$NewPointImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NewPointImplCopyWithImpl<$Res>
    extends _$PartCopyWithImpl<$Res, _$NewPointImpl>
    implements _$$NewPointImplCopyWith<$Res> {
  __$$NewPointImplCopyWithImpl(
      _$NewPointImpl _value, $Res Function(_$NewPointImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NewPointImpl implements _NewPoint {
  const _$NewPointImpl();

  @override
  String toString() {
    return 'Part.newPoint()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NewPointImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() point,
    required TResult Function() newPoint,
    required TResult Function() noPart,
  }) {
    return newPoint();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? point,
    TResult? Function()? newPoint,
    TResult? Function()? noPart,
  }) {
    return newPoint?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? point,
    TResult Function()? newPoint,
    TResult Function()? noPart,
    required TResult orElse(),
  }) {
    if (newPoint != null) {
      return newPoint();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Point value) point,
    required TResult Function(_NewPoint value) newPoint,
    required TResult Function(_NoPart value) noPart,
  }) {
    return newPoint(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Point value)? point,
    TResult? Function(_NewPoint value)? newPoint,
    TResult? Function(_NoPart value)? noPart,
  }) {
    return newPoint?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Point value)? point,
    TResult Function(_NewPoint value)? newPoint,
    TResult Function(_NoPart value)? noPart,
    required TResult orElse(),
  }) {
    if (newPoint != null) {
      return newPoint(this);
    }
    return orElse();
  }
}

abstract class _NewPoint implements Part {
  const factory _NewPoint() = _$NewPointImpl;
}

/// @nodoc
abstract class _$$NoPartImplCopyWith<$Res> {
  factory _$$NoPartImplCopyWith(
          _$NoPartImpl value, $Res Function(_$NoPartImpl) then) =
      __$$NoPartImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoPartImplCopyWithImpl<$Res>
    extends _$PartCopyWithImpl<$Res, _$NoPartImpl>
    implements _$$NoPartImplCopyWith<$Res> {
  __$$NoPartImplCopyWithImpl(
      _$NoPartImpl _value, $Res Function(_$NoPartImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoPartImpl implements _NoPart {
  const _$NoPartImpl();

  @override
  String toString() {
    return 'Part.noPart()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoPartImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() point,
    required TResult Function() newPoint,
    required TResult Function() noPart,
  }) {
    return noPart();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? point,
    TResult? Function()? newPoint,
    TResult? Function()? noPart,
  }) {
    return noPart?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? point,
    TResult Function()? newPoint,
    TResult Function()? noPart,
    required TResult orElse(),
  }) {
    if (noPart != null) {
      return noPart();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Point value) point,
    required TResult Function(_NewPoint value) newPoint,
    required TResult Function(_NoPart value) noPart,
  }) {
    return noPart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Point value)? point,
    TResult? Function(_NewPoint value)? newPoint,
    TResult? Function(_NoPart value)? noPart,
  }) {
    return noPart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Point value)? point,
    TResult Function(_NewPoint value)? newPoint,
    TResult Function(_NoPart value)? noPart,
    required TResult orElse(),
  }) {
    if (noPart != null) {
      return noPart(this);
    }
    return orElse();
  }
}

abstract class _NoPart implements Part {
  const factory _NoPart() = _$NoPartImpl;
}
